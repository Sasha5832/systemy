/*  --------------------------------------------------------------------
    Program:  dwa-podprogramy + 5 prędkości sterowane potencjometrem
              – przerwania służą WYŁĄCZNIE do:
                   • „tykania” Timer-1 (flaga do_step)
                   • przełączania trybu (CN – RD6 NEXT, RD13 PREV)
              Cała logika wężyka / kolejki działa w pętli głównej.
    MCU:      dsPIC33/PIC24  --  Fcy = 4 MHz (FRC, prescaler 1:256)
    ------------------------------------------------------------------ */
#define FCY 4000000UL
#include <xc.h>
#include <stdint.h>
#include <libpic30.h>

/* --- konfig fuzji --------------------------------------------------- */
#pragma config POSCMOD = NONE, FNOSC = FRC
#pragma config FCKSM  = CSDCMD, IESO = OFF, OSCIOFNC = OFF
#pragma config WDTPS  = PS32768, FWPSA = PR128, FWDTEN = OFF, WINDIS = ON
#pragma config ICS    = PGx2,   GWRP = OFF,  GCP  = OFF, JTAGEN = OFF

/* --- tablice -------------------------------------------------------- */
static const uint16_t periodTable[5] = { 0x0320, 0x0640, 0x0C80, 0x12C0, 0x1F40 };
static const uint8_t  snakeTable[]   = { 0x07,0x0E,0x1C,0x38,0x70,0xE0,0x70,0x38,0x1C,0x0E,0x07 };

/* --- typ wyliczeniowy na tryby ------------------------------------- */
typedef enum { MODE_SNAKE = 0, MODE_QUEUE } tMode;

/* --- zmienne współdzielone ----------------------------------------- */
static volatile tMode     mode      = MODE_SNAKE;
static volatile uint8_t   snakeIdx  = 0;

/* kolejka */
static volatile uint8_t queueTemp = 0;
static volatile uint8_t iq        = 7;
static volatile uint8_t queueKon  = 0;
static volatile uint8_t queueMove = 0;

/* timer & prędkość */
static volatile uint16_t newPR1 = 0;
static volatile uint8_t  do_step = 0;

/* --- prototypy ------------------------------------------------------ */
static void initIO(void);
static void initADC(void);
static void initTimer1(void);
static void initCN(void);
static uint16_t readPot(void);
static void updateSpeed(uint16_t adc);
static inline void resetState(void);
static inline void kontrolaKolejki(void);

/* =======================  Inicjalizacja HW  ========================= */
static void initIO(void)
{
    TRISA = 0x0000;          /* LED-y: RA0..7 wyjścia */
    LATA  = 0x0000;

    TRISD |= (1u<<6) | (1u<<13);  /* RD6, RD13 wejścia – przyciski */

    TRISBbits.TRISB5 = 1;    /* RB5 = potencjometr (AN5) */
    AD1PCFG          = 0xFFFF;
    AD1PCFGbits.PCFG5 = 0;   /* RB5 analog */
}

static void initADC(void)
{
    AD1CON1 = 0;
    AD1CON2 = 0;
    AD1CON3 = 0x1F02;        /* Tad = 2 Tcy, SAMC = 31 */
    AD1CHS  = 0x0005;        /* CH0 = AN5 */
    AD1CON1bits.ADON = 1;
}

static void initTimer1(void)
{
    T1CON = 0x8030;          /* Fcy/256, Timer1 on */
    TMR1  = 0;
    PR1   = periodTable[2];  /* środkowa prędkość startowa */
    newPR1 = PR1;

    _T1IF = 0;  _T1IP = 1;  _T1IE = 1;
}

static void initCN(void)
{
    uint16_t dummy = PORTD;  /* skasuj „mismatch” */

    CNEN2bits.CN16IE = 1;    /* RD6  – NEXT  */
    CNEN2bits.CN19IE = 1;    /* RD13 – PREV  */

    _CNIF = 0;  _CNIP = 2;  _CNIE = 1;
    (void)dummy;
}

/* =======================  Funkcje pomocnicze  ======================= */
static uint16_t readPot(void)
{
    AD1CON1bits.SAMP = 1;
    __delay_us(6);           /* ≥ (SAMC+12)·Tad ≈ 5,4 µs */
    AD1CON1bits.SAMP = 0;
    while(!AD1CON1bits.DONE);
    return ADC1BUF0 & 0x03FF;
}

static void updateSpeed(uint16_t adc)
{
    uint8_t idx =
        (adc < 205) ? 0 :
        (adc < 410) ? 1 :
        (adc < 615) ? 2 :
        (adc < 820) ? 3 : 4;

    newPR1 = periodTable[idx];   /* zapis atomowy na dsPIC33 */
}

static inline void resetState(void)
{
    snakeIdx  = 0;
    queueTemp = 0;  iq = 7;  queueKon = 0;  queueMove = 0;
    LATA = 0;
}

static inline void kontrolaKolejki(void)
{
    if(iq == 0u) { iq = 7; queueTemp = 0; queueKon = 0; }
}

/* ============================  ISR-y  =============================== */
void __attribute__((interrupt, no_auto_psv)) _T1Interrupt(void)
{
    do_step = 1;                 /* tylko SYGNAŁ „następny krok” */

    if(PR1 != newPR1) {          /* ewentualna zmiana okresu  */
        PR1  = newPR1;
        TMR1 = 0;                /* start nowej ramki od zera */
    }
    _T1IF = 0;
}

/* Change-Notification: obsługa przycisków */
void __attribute__((interrupt, no_auto_psv)) _CNInterrupt(void)
{
    __delay32(15000);            /* ≈3,75 ms debounce */
    uint8_t rd6  = PORTDbits.RD6;
    uint8_t rd13 = PORTDbits.RD13;

    if(!rd6) {                   /* NEXT (RD6 niski) */
        mode = (tMode)((mode + 1) % 2);
        resetState();
    }
    else if(!rd13) {             /* PREV (RD13 niski) */
        mode = (mode == MODE_SNAKE) ? MODE_QUEUE : MODE_SNAKE;
        resetState();
    }
    _CNIF = 0;
}

/* ============================  main()  ============================== */
int main(void)
{
    initIO();
    initADC();
    initTimer1();
    initCN();

    while(1)
    {
        updateSpeed(readPot());      /* 5 prędkości z potencjometru */

        if(do_step) {                /* Timer1 „wybił” – zrób krok */
            do_step = 0;

            switch(mode)
            {
                case MODE_SNAKE:     /* --- wężyk --- */
                    LATA = snakeTable[snakeIdx++];
                    if(snakeIdx >= sizeof(snakeTable)) snakeIdx = 0;
                    break;

                case MODE_QUEUE:     /* --- kolejka --- */
                    queueMove = (uint8_t)(1u << queueTemp);

                    if(queueTemp == iq) {
                        queueKon |= queueMove;
                        iq--;  queueTemp = 0;
                    }
                    else {
                        queueKon |= queueMove;
                        queueTemp++;
                    }
                    LATA = queueKon;
                    kontrolaKolejki();
                    break;
            }
        }
    }
}
